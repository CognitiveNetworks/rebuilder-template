#!/bin/bash

# Legacy Rebuild Process Runner
# Launches Cascade to execute the rebuild analysis process
#
# Usage:
#   ./run.sh /path/to/inputs           # Reads from a directory containing input.md and scope.md
#
# The input directory should be created per project:
#   mkdir -p rebuild-inputs/my-project
#   git clone <legacy-repo-url> rebuild-inputs/my-project/repo
#   cp scope.md rebuild-inputs/my-project/scope.md
#   cp rebuild/input.md rebuild-inputs/my-project/input.md
#
# For multi-repo rebuilds, clone adjacent repos into adjacent/:
#   git clone <adjacent-repo-url> rebuild-inputs/my-project/adjacent/other-app
#
# All outputs (analysis, agent configs, ADRs) are written into the input directory,
# keeping each legacy repo's rebuild artifacts self-contained.

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(dirname "$SCRIPT_DIR")"

# Input directory is required
if [ -z "$1" ]; then
    echo "Usage: ./run.sh /path/to/input-directory"
    echo ""
    echo "Create an input directory per project:"
    echo "  mkdir -p rebuild-inputs/my-project"
    echo "  cp scope.md rebuild-inputs/my-project/scope.md"
    echo "  cp rebuild/input.md rebuild-inputs/my-project/input.md"
    exit 1
fi

INPUT_DIR="$(cd "$1" && pwd)"
INPUT_FILE="$INPUT_DIR/input.md"
SCOPE_FILE="$INPUT_DIR/scope.md"

# Verify input files exist
if [ ! -f "$INPUT_FILE" ]; then
    echo "Error: input.md not found at $INPUT_FILE"
    exit 1
fi
if [ ! -f "$SCOPE_FILE" ]; then
    echo "Error: scope.md not found at $SCOPE_FILE"
    exit 1
fi

# Create output directories inside the input directory
mkdir -p "$INPUT_DIR/output"
mkdir -p "$INPUT_DIR/sre-agent"
mkdir -p "$INPUT_DIR/developer-agent"
mkdir -p "$INPUT_DIR/docs/adr"
mkdir -p "$INPUT_DIR/docs/postmortems"

# Copy template agent configs into the project directory (skip if already present)
for file in WINDSURF_SRE.md config.md; do
    if [ ! -f "$INPUT_DIR/sre-agent/$file" ]; then
        cp "$REPO_DIR/sre-agent/$file" "$INPUT_DIR/sre-agent/$file"
    fi
done
for file in WINDSURF_DEV.md config.md; do
    if [ ! -f "$INPUT_DIR/developer-agent/$file" ]; then
        cp "$REPO_DIR/developer-agent/$file" "$INPUT_DIR/developer-agent/$file"
    fi
done
# Copy .windsurfrules template (goes into the built repo root at deploy time)
if [ ! -f "$INPUT_DIR/developer-agent/.windsurfrules" ]; then
    cp "$REPO_DIR/developer-agent/.windsurfrules" "$INPUT_DIR/developer-agent/.windsurfrules"
fi
# Copy .github/copilot-instructions.md template (for VS Code + GitHub Copilot users)
mkdir -p "$INPUT_DIR/developer-agent/.github"
if [ ! -f "$INPUT_DIR/developer-agent/.github/copilot-instructions.md" ]; then
    cp "$REPO_DIR/developer-agent/.github/copilot-instructions.md" "$INPUT_DIR/developer-agent/.github/copilot-instructions.md"
fi

# Copy doc templates that are filled out later (skip if already present)
for file in cutover-report.md disaster-recovery.md; do
    if [ ! -f "$INPUT_DIR/docs/$file" ]; then
        cp "$REPO_DIR/docs/$file" "$INPUT_DIR/docs/$file"
    fi
done
# feature-parity.md and data-migration-mapping.md are generated by Steps 9-10

# Detect adjacent repos (optional — for multi-repo rebuilds)
ADJACENT_PROMPT=""
if [ -d "$INPUT_DIR/adjacent" ]; then
    ADJACENT_REPOS=""
    for dir in "$INPUT_DIR/adjacent"/*/; do
        if [ -d "$dir" ]; then
            ADJACENT_REPOS="$ADJACENT_REPOS $dir"
        fi
    done
    if [ -n "$ADJACENT_REPOS" ]; then
        ADJACENT_PROMPT=" Also read the adjacent codebases at:$ADJACENT_REPOS — these are repos that work with the primary codebase and are included in the rebuild scope. Analyze their integration points, shared state, and coupling with the primary repo as described in the process."
    fi
fi

echo "Reading inputs from:"
echo "  input.md: $INPUT_FILE"
echo "  scope.md: $SCOPE_FILE"
if [ -n "$ADJACENT_PROMPT" ]; then
    echo "  adjacent repos:"
    for dir in "$INPUT_DIR/adjacent"/*/; do
        [ -d "$dir" ] && echo "    $(basename "$dir"): $dir"
    done
fi
echo ""
echo "Writing outputs to:"
echo "  $INPUT_DIR/output/"
echo "  $INPUT_DIR/sre-agent/"
echo "  $INPUT_DIR/developer-agent/"
echo "  $INPUT_DIR/docs/"
echo ""

# Run from the repo root so the CLI can access both rebuild/ and rebuild-inputs/
# Use -p (print mode) for non-interactive execution
# Use --dangerously-skip-permissions since this is an automated analysis process
# Unset WINDSURF_SESSION to allow invocation from within another Windsurf session
(
  cd "$REPO_DIR" || exit 1
  unset WINDSURF_SESSION
  windsurf -p --dangerously-skip-permissions \
    "Read $SCRIPT_DIR/IDEATION_PROCESS.md, $INPUT_FILE, and $SCOPE_FILE. Execute the process.$ADJACENT_PROMPT Write Steps 1-5 outputs to $INPUT_DIR/output/. After generating the PRD: update the SRE agent config at $INPUT_DIR/sre-agent/WINDSURF_SRE.md and $INPUT_DIR/sre-agent/config.md as described in Step 6, populate the developer agent config at $INPUT_DIR/developer-agent/WINDSURF_DEV.md and $INPUT_DIR/developer-agent/config.md as described in Step 7 (Steps 7a and 7b), then per Step 7c place the IDE instruction files (.windsurfrules and .github/copilot-instructions.md) AND the populated developer-agent/WINDSURF_DEV.md and developer-agent/config.md inside the built repository directory so developers get auto-loaded configs when they clone and open the repo in any IDE. Generate ADRs in $INPUT_DIR/docs/adr/ as described in Step 8, generate the feature parity matrix at $INPUT_DIR/docs/feature-parity.md as described in Step 9, and generate the data migration mapping at $INPUT_DIR/docs/data-migration-mapping.md as described in Step 10."
)
